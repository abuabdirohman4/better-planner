---
description: "Database schema reference, data validation, and Supabase integration patterns"
globs: ["**/lib/**/*.ts", "**/api/**/*.ts", "**/hooks/**/*.ts", "**/types.ts", "**/supabase/**/*.ts"]
alwaysApply: true
---

# Database Schema Reference

## Overview

Better Planner uses Supabase (PostgreSQL) as the primary database. This file contains comprehensive reference for database structure, data validation, and API integration patterns.

## Database Documentation

**ðŸ“‹ Main Reference**: `docs/database-schema.md`

This file contains complete documentation about:
- Projects and Tasks table structure
- Data formats and validation
- Supabase integration patterns
- Business rules and constraints
- Performance considerations

## Quick Reference

### Projects Table Structure

```typescript
interface Project {
    id: string;                    // Primary key (UUID)
    title: string;                 // Project name
    description: string;           // Project description
    status: "planning" | "active" | "completed" | "on-hold";
    priority: "low" | "medium" | "high" | "urgent";
    color: string;                 // Project color
    userId: string;                // Foreign key to auth.users
    quarter: string;               // Q1, Q2, Q3, Q4
    startDate: string;             // Start date (YYYY-MM-DD)
    endDate: string;               // End date (YYYY-MM-DD)
    createdAt: string;             // Creation timestamp
    updatedAt: string;             // Last update timestamp
}
```

### Tasks Table Structure

```typescript
interface Task {
    id: string;                    // Primary key (UUID)
    projectId: string;             // Foreign key to Projects
    title: string;                 // Task name
    description: string;           // Task description
    status: "todo" | "in-progress" | "completed";
    priority: "low" | "medium" | "high" | "urgent";
    dueDate?: string;              // Due date (YYYY-MM-DD)
    completedAt?: string;          // Completion timestamp
    createdAt: string;             // Creation timestamp
    updatedAt: string;             // Last update timestamp
}
```

## Data Validation Rules

### UUID Format
- **Database**: UUID v4 format
- **API**: String format
- **Validation**: Must be valid UUID format
- **Example**: `"550e8400-e29b-41d4-a716-446655440000"`

### Date Formats
- **Database**: `YYYY-MM-DD` for date fields
- **DateTime**: `YYYY-MM-DDTHH:MM:SS.sssZ` (ISO 8601)
- **API**: ISO 8601 format
- **Timezone**: UTC for all timestamps

### Status Values
- **Project Status**: `"planning" | "active" | "completed" | "on-hold"`
- **Task Status**: `"todo" | "in-progress" | "completed"`
- **Priority**: `"low" | "medium" | "high" | "urgent"`
- **Quarter**: `"Q1" | "Q2" | "Q3" | "Q4"`

### Color Format
- **Format**: Hex color code
- **Example**: `"#1496F6"`, `"#10B981"`
- **Validation**: Must be valid hex color
- **Default**: `"#1496F6"` (primary blue)

## API Integration Patterns

### Supabase Data Processing

```typescript
// Data transformation from Supabase
const transformSupabaseData = (row: any): Project => ({
    id: row.id,
    title: row.title,
    description: row.description || "",
    status: row.status as "planning" | "active" | "completed" | "on-hold",
    priority: row.priority as "low" | "medium" | "high" | "urgent",
    color: row.color || "#1496F6",
    userId: row.user_id,
    quarter: row.quarter,
    startDate: row.start_date,
    endDate: row.end_date,
    createdAt: row.created_at,
    updatedAt: row.updated_at,
});

// Task data transformation
const transformTaskData = (row: any): Task => ({
    id: row.id,
    projectId: row.project_id,
    title: row.title,
    description: row.description || "",
    status: row.status as "todo" | "in-progress" | "completed",
    priority: row.priority as "low" | "medium" | "high" | "urgent",
    dueDate: row.due_date || undefined,
    completedAt: row.completed_at || undefined,
    createdAt: row.created_at,
    updatedAt: row.updated_at,
});
```

### Error Handling

```typescript
// Supabase error handling
const handleSupabaseError = (error: any) => {
    console.error("Supabase operation error:", error);
    // Return user-friendly error message
    return {
        message: "Failed to process data. Please try again.",
        code: error.code,
        details: error.details
    };
};

// Data validation
const validateProjectData = (data: CreateProjectData) => {
    if (!data.title || data.title.length > 100) {
        throw new Error("Title must be 1-100 characters");
    }
    if (!["planning", "active", "completed", "on-hold"].includes(data.status)) {
        throw new Error("Status must be 'planning', 'active', 'completed', or 'on-hold'");
    }
    if (!["Q1", "Q2", "Q3", "Q4"].includes(data.quarter)) {
        throw new Error("Quarter must be 'Q1', 'Q2', 'Q3', or 'Q4'");
    }
    if (!data.startDate || !data.endDate) {
        throw new Error("Start date and end date are required");
    }
};
```

## Business Rules

### 1. Project Creation
- `id` must be unique UUID
- `title` cannot be empty (1-100 characters)
- `description` is optional and can be empty
- `status` only "planning", "active", "completed", "on-hold"
- `priority` only "low", "medium", "high", "urgent"
- `quarter` only "Q1", "Q2", "Q3", "Q4"
- `start_date` and `end_date` are required
- `user_id` must reference existing auth.users

### 2. Task Management
- `project_id` must reference existing Projects
- `title` cannot be empty (1-100 characters)
- `description` is optional and can be empty
- `status` only "todo", "in-progress", "completed"
- `priority` only "low", "medium", "high", "urgent"
- `due_date` is optional but cannot be in the past
- `completed_at` is set when status changes to "completed"

### 3. Data Integrity
- Cannot delete project that has tasks
- Update project must maintain reference in Tasks
- RLS policies ensure users can only access their own data
- Cascade delete: deleting project deletes all its tasks

## Performance Guidelines

### 1. Supabase Optimization
- Use proper indexing on frequently queried columns
- Implement RLS policies for efficient data filtering
- Use SWR for client-side caching and revalidation
- Batch operations for multiple updates

### 2. Data Filtering
- Filter by `user_id` at database level using RLS
- Implement pagination for large datasets
- Cache frequently accessed data with SWR
- Use proper WHERE clauses for efficient queries

### 3. Error Recovery
- Implement retry mechanism for network errors
- Use Supabase real-time subscriptions for live updates
- Graceful degradation for connection issues
- Proper error boundaries for UI error handling

## Common Patterns

### 1. Fetching Projects
```typescript
const { projects, isLoading, error } = useProjects();

// Filter active projects
const activeProjects = projects.filter(project => project.status === 'active');
```

### 2. Toggle Task Completion
```typescript
const { toggleTaskStatus } = useTasks(projectId);

const handleToggle = async (taskId: string) => {
    try {
        await toggleTaskStatus(taskId);
        // UI will update automatically via SWR
    } catch (error) {
        console.error("Failed to toggle task status:", error);
    }
};
```

### 3. Creating New Project
```typescript
const { createProject } = useProjects();

const handleCreateProject = async (projectData: CreateProjectData) => {
    try {
        const newProject = await createProject(projectData);
        // Navigate or update UI
    } catch (error) {
        console.error("Failed to create project:", error);
    }
};
```

## Development Guidelines

### 1. Type Safety
- Always use TypeScript interfaces
- Validate data on client and server
- Handle type conversion correctly

### 2. Error Handling
- Implement proper error boundaries
- Return user-friendly error messages
- Log errors for debugging
- Handle Supabase-specific errors

### 3. Testing
- Test data transformation functions
- Mock Supabase API responses
- Test error scenarios
- Test RLS policies

## Migration & Updates

### 1. Schema Changes
- Always add new columns at the end
- Do not remove existing columns
- Use default values for new columns

### 2. Data Migration
- Backup data before schema changes
- Test migration in staging environment
- Rollback plan if migration fails

## Security Considerations

### 1. Data Validation
- Validate all input data
- Sanitize data before saving
- Implement rate limiting

### 2. Access Control
- Use RLS policies for data access control
- Implement proper authentication with Supabase Auth
- Do not expose sensitive data
- Audit log for data access

## Monitoring

### 1. Data Quality
- Monitor data consistency
- Alert for corrupted data
- Regular data validation

### 2. Performance
- Track API response times
- Monitor error rates
- Measure cache hit rates

---

**ðŸ“š For complete information, see**: `docs/database-schema.md`

**ðŸ”§ For API implementation, see**: `.cursor/rules/api-integration.mdc`

**ðŸ’¡ For component patterns, see**: `.cursor/rules/component-patterns.mdc`