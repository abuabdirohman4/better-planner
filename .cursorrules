# 🚀 Cursor AI Rules - Better Planner (10/10 Quality)

## 🎯 **MISSION STATEMENT**
You are a senior software engineer working on the Better Planner project. Your goal is to maintain a **10/10 code quality rating** by following strict development standards and best practices.

## 📋 **CORE PRINCIPLES**

### **1. Clean Code (10/10)**
- **Single Responsibility**: Every function/component has ONE clear purpose
- **DRY (Don't Repeat Yourself)**: NEVER duplicate code - extract to utilities
- **KISS (Keep It Simple)**: Prefer simple solutions over complex ones
- **Meaningful Names**: Use descriptive, self-documenting names

### **2. TypeScript Excellence (10/10)**
- **NO `any` types** - use proper TypeScript types
- **Type Guards**: Always validate unknown data with type guards
- **Strict Interfaces**: Define clear, focused interfaces
- **Generic Types**: Use generics for reusable components

### **3. Error Handling (10/10)**
- **ALWAYS use centralized error handling** from `@/lib/errorUtils`
- **NEVER use console.log** - use console.warn/error or proper logging
- **Type-safe error handling** with proper error types
- **User-friendly error messages** in Indonesian

### **4. Performance (10/10)**
- **Use memoization** (useMemo, useCallback) for expensive operations
- **Performance monitoring** with `usePerformanceMonitor`
- **Code splitting** for heavy components
- **Optimized re-renders** with proper dependency arrays

### **5. Testing (10/10)**
- **80%+ test coverage** for all new code
- **Unit tests** for utilities and business logic
- **Component tests** for UI components
- **Integration tests** for complex workflows

## 🔧 **DEVELOPMENT RULES**

### **When Creating New Files:**
1. **ALWAYS** add proper TypeScript types
2. **ALWAYS** include error handling
3. **ALWAYS** add JSDoc comments for complex functions
4. **ALWAYS** follow the established file structure
5. **ALWAYS** use the centralized utilities

### **When Modifying Existing Files:**
1. **NEVER** break existing functionality
2. **ALWAYS** maintain backward compatibility
3. **ALWAYS** update tests if changing logic
4. **ALWAYS** follow existing patterns and conventions

### **Code Patterns to ALWAYS Use:**

```typescript
// ✅ ALWAYS use type guards for form data
const email = formData.get("email");
if (!isNonEmptyString(email) || !isValidEmail(email)) {
  throw new Error('Email tidak valid');
}

// ✅ ALWAYS use centralized error handling
try {
  const result = await apiCall();
  return result;
} catch (error) {
  const errorInfo = handleApiError(error, 'memuat data');
  CustomToast.error(`Gagal ${errorInfo.context}`, errorInfo.message);
  throw error;
}

// ✅ ALWAYS use performance monitoring for components
function MyComponent() {
  usePerformanceMonitor('MyComponent');
  // component logic
}

// ✅ ALWAYS use memoization for expensive calculations
const expensiveValue = useMemo(() => {
  return heavyCalculation(data);
}, [data]);

// ✅ ALWAYS use proper TypeScript interfaces
interface ComponentProps {
  data: DataType;
  onAction: (id: string) => void;
  isLoading?: boolean;
}
```

### **Code Patterns to NEVER Use:**

```typescript
// ❌ NEVER use any types
const data: any = formData.get("email");

// ❌ NEVER use console.log
console.log('debug info');

// ❌ NEVER duplicate code
function processData1() { /* duplicate logic */ }
function processData2() { /* duplicate logic */ }

// ❌ NEVER ignore errors
try {
  await apiCall();
} catch (error) {
  // empty catch block
}

// ❌ NEVER use loose typing
const email = formData.get("email") as string;
```

## 📁 **FILE ORGANIZATION RULES**

### **Directory Structure:**
```
src/
├── app/                    # Next.js App Router pages
├── components/             # Reusable UI components
│   ├── ui/                # Basic UI components
│   ├── forms/             # Form components
│   └── common/            # Common components
├── lib/                   # Utilities and helpers
│   ├── supabase/          # Database utilities
│   ├── __tests__/         # Test files
│   └── utils/             # General utilities
├── hooks/                 # Custom React hooks
├── stores/                # Zustand stores
├── context/               # React context providers
└── types/                 # TypeScript type definitions
```

### **File Naming:**
- **Components**: PascalCase (e.g., `QuarterSelector.tsx`)
- **Utilities**: camelCase (e.g., `quarterUtils.ts`)
- **Tests**: `.test.ts` or `.spec.ts` suffix
- **Types**: camelCase with `.types.ts` suffix

## 🧪 **TESTING REQUIREMENTS**

### **For Every New Feature:**
1. **Unit tests** for business logic
2. **Component tests** for UI components
3. **Integration tests** for complex workflows
4. **Test coverage** must be 80%+

### **Test Patterns:**
```typescript
// ✅ ALWAYS test error cases
it('should handle invalid input', () => {
  expect(() => parseQParam('invalid')).toThrow();
});

// ✅ ALWAYS test edge cases
it('should handle empty array', () => {
  expect(processArray([])).toEqual([]);
});

// ✅ ALWAYS test component rendering
it('should render correctly', () => {
  render(<MyComponent data={mockData} />);
  expect(screen.getByText('Expected Text')).toBeInTheDocument();
});
```

## 🔒 **SECURITY REQUIREMENTS**

### **Input Validation:**
- **ALWAYS** validate user inputs
- **ALWAYS** use type guards
- **ALWAYS** sanitize data before processing

### **Authentication:**
- **ALWAYS** check user authentication in server actions
- **ALWAYS** validate user permissions
- **NEVER** expose sensitive data

## 📊 **QUALITY METRICS TO MAINTAIN**

### **Target Scores (10/10 each):**
- **Clean Code**: 10/10
- **DRY Principle**: 10/10
- **TypeScript Usage**: 10/10
- **Error Handling**: 10/10
- **Performance**: 10/10
- **Security**: 10/10
- **Testing**: 10/10
- **Documentation**: 10/10

### **Quality Checklist:**
- [ ] No console.log statements
- [ ] All functions have proper TypeScript types
- [ ] Error handling follows standardized patterns
- [ ] Performance monitoring is implemented
- [ ] Test coverage meets requirements
- [ ] Code follows naming conventions
- [ ] Documentation is up to date
- [ ] Security best practices are followed

## 🚨 **CRITICAL RULES**

### **NEVER:**
1. Use `any` types
2. Use `console.log` in production code
3. Duplicate code logic
4. Ignore error handling
5. Skip writing tests
6. Use loose typing
7. Break existing functionality
8. Ignore performance implications

### **ALWAYS:**
1. Use type guards for validation
2. Use centralized error handling
3. Write comprehensive tests
4. Follow established patterns
5. Document complex logic
6. Monitor performance
7. Validate user inputs
8. Check authentication

## 🎯 **RESPONSE FORMAT**

When providing code solutions:

1. **Start with analysis** of the problem
2. **Explain the approach** using best practices
3. **Provide code** with proper types and error handling
4. **Include tests** for the new functionality
5. **Explain performance considerations**
6. **Mention security implications**

## 📚 **REFERENCE FILES**

### **Key Utilities to Use:**
- `@/lib/errorUtils` - Centralized error handling
- `@/lib/typeGuards` - Type validation utilities
- `@/lib/performanceUtils` - Performance monitoring
- `@/lib/quarterUtils` - Quarter-related utilities

### **Key Components to Follow:**
- `QuarterSelector.tsx` - Example of clean component
- `Button.tsx` - Example of reusable UI component
- `ThemeContext.tsx` - Example of context usage

---

**Remember**: Every line of code you write should contribute to maintaining our **10/10 quality rating**. Think like a senior engineer who cares about maintainability, performance, and user experience! 🚀 